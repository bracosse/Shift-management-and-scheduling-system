import sqlite3
from datetime import datetime, timedelta
import calendar

DB_PATH = 'company_schedule.db'
SHIFT_TYPES = ['Morning', 'Evening', 'Night']

SHIFT_HOURS = {
    'Morning': '08:00-16:00',
    'Evening': '16:00-00:00',
    'Night': '00:00-08:00',
    'Off': 'Off',
    'Leaver': 'Leaver',
    'Annual Leave': 'Annual Leave'
}

ROLE_IDS = {
    'Manager': 1,
    'HR': 2,
    'Team Leader': 3,
    'Employee': 4
}

def check_if_shifts_generated_for_month(year, month):
    """
    Check if shifts for the given year and month are already present in the database.
    Returns True if shifts exist, otherwise False.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # Get the first and last date of the given month
    start_date = datetime(year, month, 1).strftime("%Y-%m-%d")
    _, last_day = calendar.monthrange(year, month)
    end_date = datetime(year, month, last_day).strftime("%Y-%m-%d")

    cursor.execute('''
        SELECT COUNT(*) FROM Shifts
        WHERE Date BETWEEN ? AND ?
    ''', (start_date, end_date))
    result = cursor.fetchone()
    conn.close()

    return result[0] > 0  # If count is greater than 0, shifts already exist

def get_employees_by_role():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()
    cursor.execute("SELECT EmployeeID, Name, RoleID, EndDate FROM Employees")
    employees = cursor.fetchall()
    conn.close()

    roles = {'Manager': [], 'HR': [], 'Team Leader': [], 'Employee': []}
    for emp_id, name, role_id, end_date in employees:
        for role_name, role_val in ROLE_IDS.items():
            if role_id == role_val:
                roles[role_name].append((emp_id, name, end_date))
    return roles

def generate_dates_for_month(year, month):
    _, last_day = calendar.monthrange(year, month)
    return [datetime(year, month, day) for day in range(1, last_day + 1)]

def get_approved_holidays_for_month(year, month):
    """
    Get the approved holidays for the given year and month.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    start_date = datetime(year, month, 1).strftime("%Y-%m-%d")
    _, last_day = calendar.monthrange(year, month)
    end_date = datetime(year, month, last_day).strftime("%Y-%m-%d")

    cursor.execute('''
        SELECT EmployeeID, HolidayStartDate, HolidayEndDate
        FROM Holidays
        WHERE Status = 'Approved' AND HolidayStartDate BETWEEN ? AND ?
        AND HolidayEndDate BETWEEN ? AND ?
    ''', (start_date, end_date, start_date, end_date))

    holidays = cursor.fetchall()
    conn.close()

    approved_holidays = {}
    for emp_id, start_date, end_date in holidays:
        start_date = datetime.strptime(start_date, "%Y-%m-%d")
        end_date = datetime.strptime(end_date, "%Y-%m-%d")

        if emp_id not in approved_holidays:
            approved_holidays[emp_id] = []

        current_date = start_date
        while current_date <= end_date:
            approved_holidays[emp_id].append(current_date.date())
            current_date += timedelta(days=1)

    return approved_holidays

def assign_shifts_for_roles():
    roles = get_employees_by_role()
    today = datetime.today()

    while True:
        month_input = input("Enter the month (YYYY-MM) to generate shifts for (current or next 2 months only): ")
        try:
            target_date = datetime.strptime(month_input, "%Y-%m")
            if target_date < today.replace(day=1) or target_date > (today.replace(day=1) + timedelta(days=62)):
                print("Invalid month range. Try again.")
            else:
                break
        except ValueError:
            print("Invalid format. Use YYYY-MM.")

    year, month = target_date.year, target_date.month
    if check_if_shifts_generated_for_month(year, month):
        print(f"Shifts for {calendar.month_name[month]} {year} are already generated.")
        return
    all_dates = generate_dates_for_month(year, month)
    
    # Get approved holidays for the month
    approved_holidays = get_approved_holidays_for_month(year, month)

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # Manager & HR: Monday to Friday, Morning, weekends off
    for role in ['Manager', 'HR']:
        for emp_id, name, end_date in roles[role]:
            # Check if the employee's end date is during the target month
            if end_date:
                end_date = datetime.strptime(end_date, "%Y-%m-%d")
                # If end date is within the month, mark remaining days as 'Leaver'
                if end_date < target_date:
                    for date in all_dates:
                        cursor.execute('''
                            INSERT INTO Shifts (EmployeeID, Date, ShiftType, EmployeeName, Role)
                            VALUES (?, ?, ?, ?, ?)
                        ''', (emp_id, date.date(), 'Leaver', name, role))
                    continue

            for date in all_dates:
                # If the employee has an approved holiday on this date, mark as Annual Leave
                shift_type = 'Annual Leave' if date.date() in approved_holidays.get(emp_id, []) else 'Morning' if date.weekday() < 5 else 'Off'
                cursor.execute('''
                    INSERT INTO Shifts (EmployeeID, Date, ShiftType, EmployeeName, Role)
                    VALUES (?, ?, ?, ?, ?)
                ''', (emp_id, date.date(), shift_type, name, role))

    # Team Leaders & Employees: 24/7 rotation with distributed shifts and staggered off days
    for role in ['Team Leader', 'Employee']:
        staff = roles[role]
        num_staff = len(staff)
        shift_rotation = {emp_id: i % 3 for i, (emp_id, _, _) in enumerate(staff)}
        off_day_rotation = {emp_id: (i % 7, (i + 3) % 7) for i, (emp_id, _, _) in enumerate(staff)}

        for emp_id, name, end_date in staff:
            # Check if the employee's end date is during the target month
            if end_date:
                end_date = datetime.strptime(end_date, "%Y-%m-%d")
                # If end date is within the month, mark remaining days as 'Leaver'
                if end_date < target_date:
                    for date in all_dates:
                        cursor.execute('''
                            INSERT INTO Shifts (EmployeeID, Date, ShiftType, EmployeeName, Role)
                            VALUES (?, ?, ?, ?, ?)
                        ''', (emp_id, date.date(), 'Leaver', name, role))
                    continue

            current_shift_index = shift_rotation[emp_id]
            off_days = off_day_rotation[emp_id]

            for week_start in range(0, len(all_dates), 7):
                week_dates = all_dates[week_start:week_start + 7]
                shift_type = SHIFT_TYPES[current_shift_index % 3]

                for i, date in enumerate(week_dates):
                    shift = None
                 # First, check if the employee has an approved holiday (Annual Leave) for this date
                    if date.date() in approved_holidays.get(emp_id, []):
                        shift = 'Annual Leave'
                    elif date.weekday() in off_days:
                # Only assign "Off" if the employee is not on Annual Leave for this date
                      shift = 'Off' if shift != 'Annual Leave' else 'Annual Leave'
                    else:
                        shift = shift_type
        
                    cursor.execute('''
                         INSERT INTO Shifts (EmployeeID, Date, ShiftType, EmployeeName, Role)
                         VALUES (?, ?, ?, ?, ?)
                         ''', (emp_id, date.date(), shift, name, role))
                current_shift_index += 1

    conn.commit()
    conn.close()
    print(f"Shifts for {calendar.month_name[month]} {year} generated successfully.")


def update_shifts_for_holiday(employee_id, holiday_start, holiday_end):
    """
    Update shift entries to 'Annual Leave' for an employee with an approved holiday.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    # Ensure holiday is approved
    cursor.execute('''
        SELECT 1 FROM Holidays
        WHERE EmployeeID = ? AND HolidayStartDate = ? AND HolidayEndDate = ? AND Status = 'Approved'
    ''', (employee_id, holiday_start, holiday_end))
    
    if cursor.fetchone():  # Holiday is approved
        cursor.execute('''
            UPDATE Shifts
            SET ShiftType = 'Annual Leave'
            WHERE EmployeeID = ?
            AND Date BETWEEN ? AND ?
        ''', (employee_id, holiday_start, holiday_end))
        print(f"Updated shifts to 'Annual Leave' for EmployeeID {employee_id}.")
    else:
        print("No approved holiday found. Shifts not updated.")

    conn.commit()
    conn.close()

if __name__ == "__main__":
    assign_shifts_for_roles()



# cursor.execute('''
#         UPDATE Shifts
#         SET ShiftType = 'Annual Leave'
#         WHERE EmployeeID = ?
#         AND Date BETWEEN ? AND ? 
#     ''', (employee_id, holiday_start, holiday_end))